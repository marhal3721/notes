
- [第一章.MySQL架构与历史](#1)
	- [MySQL逻辑架构](#1.1)
	- [并发控制](#1.2)
	- [事务](#1.3)
	- [多版本并发控制](#1.4)
	- [MySQL的存储引擎](#1.5)
	- [MySQL时间线(Timeline)](#1.6)
	- [MySQL的开发模式](#1.7)
	- [总结](#1.8)


# <a id="1">MySQL架构与历史</a>

## <a id="1.1">MySQL逻辑架构</a>

![MySQL逻辑架构图例](./img/1.1.jpg)

* 最上层：大多基于网络的客户端/服务器的工具挥着服务都有类似的架构（如：链接处理、授权认证、安全等）
* 第二层: mysql核心功能。
	* 包括`查询解析`、`分析`、`优化`、`缓存`以及所有的`内置函数`(时间、日期、数学和加密函数)。
	* 所有跨存储引擎的功能都在这一层实现：`存储过程`、`触发器`、`视图`等
* 第三层：包含了存储引擎。
	* 存储引擎负责mysql中数据的存储和提取
	* 服务器通过api与存储引擎通信
	* 存储引擎不会解析sql（innodb例外，她会解析外键定义，因为mysql服务器本身没有实现该功能）
	* 不同的存储引擎不会相互通信，只是简单地响应上层服务器的请求

### 1.1.1 连接管理与安全性
* 每个客户端连接都会在服务器进程中拥有一个线程，该连接的查询只会在这个单独的线程中执行
* 连接mysql服务器认证
	* 基于用户名、原始主机信息和密码
	* 如果用了安全套接字（SSL）方式，还可以使用X.509证书认证
	* 连接成功后服务器会验证客户端执行操作的权限

### 1.1.2 优化与执行
* mysql解析查询&创建内部数据结构 -> 优化（重写查询、决定表的读取顺序、选择合适和索引）-> 执行
* select查询
	* 检查到查询缓存(Query Cache) -> 直接返回结果集
	* 未检查到查询缓存->查询解析->优化->执行

## <a id="1.2">并发控制</a>
* 只要有多个查询需要`在同一时刻修改数据`，都会产出并发控制的问题
* mysql在两个层面的并发控制：`服务器层`、`存储引擎层`

### <a id="1.2.1">读写锁</a>
* 共享锁(读锁)
    * 共享的，相互不阻塞的。多个客户可在同一时刻可以同时读取一个资源而互不干扰。
* 排他锁(写锁)
    * 一个写锁会阻塞其他的写锁和读锁

### <a id="1.2.1">锁粒度</a>
* 表锁（table lock）
    * mysql中最基本的锁策略，`开销最小`的策略
    * 锁定整张表
    * 用户对表就行写操作前，需要先获得写锁，这回阻塞其他用户对表的所有读写操作。
    * 在使用`ALTER TABLE`之类操作时会使用表锁而忽略存储引擎的锁机制
* 行级锁（row lock）
    * 可以最大程度地支持并发处理，同时也带来了`最大的锁开销`
    * 只在存储引擎实现，mysql服务器层没有实现
    
## <a id="1.3">事务</a>
* 事务就是一组原子性的sql查询，或者说一个独立的工作单元
* 事务内的语句，要么全部执行，要么全部执行失败

### 事务的`ACID`
* **原子性**（atomicity）
    * 一个事务必须被视为一个`不可分割的最小工作单元`
    * 整个事务中的所有操作要么全部提交成功，要么全部失败回滚
* **一致性**（consistency）
    * 数据库总是从一个一致性的状态转换到另外一个一致性的状态
    * 事务最终没有提交，事务中锁座的修改也不会保存在数据库中
* **隔离性**（isolation）
    * 通常一个事务所做的修改在最终提交之前，对其他事务是不可见的
    * 事务的`隔离级别`（isolation level）
* **持久性**（durability）
    * 一旦事务提交，则其锁座的修改就会永久保存到数据库中
    
### <a id="1.3.1">隔离级别</a>
* **READ UNCOMMITTED (未提交读)**
    * 事务中的修改即使没有提交，对其他事务也都是可见的
    * 事务可以读取未提交的数据，被称为`脏读`
    * 实际应用中一般很少使用
* **READ COMMITTED (提交读)**
    * 大多数数据库系统的默认隔离级别（mysql不是）
    * 又称`不可重复读`
    * 一个事务从开始到提交之前，所做的任何修改对其他事务都是不可见的
* **REPEATABLE READ (可重复读)**
    * mysql的`默认事务隔离级别`
    * 解决了`脏读`的问题
    * 保证了在同一个事务中多次读取同样的记录的结果是一致的
    * 还是无法解决`幻读`（***当某个事务在读取某个范围内的记录是，另外一个又在改范围插入了新的记录，当之前的事务再次读取该范围的记录时没回产生幻行***）的问题
    * InnoDB和XtraDB存储引擎通过多版本并发控制(MVCC)解决了幻读的问题
* **SERIALIZABLE (可串行化)**
    * `最高的隔离级别`
    * 通过强制事务串行执行，避免了`幻读`的问题
    * 在读取的每一行数据都加锁，所以可能导致大量的超时和锁争用的问题
    * 只有在非常需要确保数据的一致性而且可以接受没有并发的情况下，才考虑使用

| 隔离级别 | 脏读可能性 | 不可重复读可能性 | 幻读可能性 | 加锁读 |
| :---: | :----: | :----: | :----: |:----: |
|READ UNCOMMITTED | yes| yes | yes | no |
|READ COMMITTED |no|yes|yes|no|
|REPEATABLE READ |no|no|yes|no|
|SERIALIZABLE |no|no|no|yes|

### <a id="1.3.2">死锁</a>

* 死锁是指两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。
* 当多个事务试图以不同的顺序锁定资源时，就可能产生死锁
* 多个事务同事锁定同一个资源时，也会产生死锁。

---
**解决**
* 1.检测到死锁的循环依赖，并立即返回一个错误
* 2.查询时间达到锁等待超时的设定后放弃锁请求（不好的处理方式）
* innodb目前处理方法：将持有最少行级排他锁的事务进行回滚

---
**分析**
* 锁的行为和顺序是和存储引擎相关的
* 死锁的原因：
    * 有些事因为`真正的数据冲突`
    * 有些则完全是由于存储引擎的实现方式导致的
* 死锁发生后，只有部分或者回滚其中一个事务，才能打破死锁
* 在`应用程序设计`时必须考虑如何处理死锁

### <a id="1.3.3">事务日志</a>

## <a id="1.4">多版本并发控制</a>
## <a id="1.5">MySQL的存储引擎</a>
## <a id="1.6">MySQL时间线(Timeline)</a>
## <a id="1.7">MySQL的开发模式</a>
## <a id="1.8">总结</a>

