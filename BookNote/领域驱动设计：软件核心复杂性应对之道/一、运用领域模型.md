# 第一章： 消化知识

* 探针仿真（probesimulation）
  * 探针仿真跟踪信号的传播，以便检测在设计中可能出现特定类型问题的位臵

* 一边进行“头脑风暴”式的讨论，一边对模型进行精化，边提问边回答
  * 当模型对象无法清楚地表达某个重要场景时，我们就通过头脑风暴活动创建新的模型对象或者修改原有的模型对象，并消化理解这些模型对象中的知识
  * 在精化模型的过程中，代码也随之一步步演进

## 1.1 有效建模的要素
### 模型和实现的绑定
* 最初的原型虽然简陋，但它在模型与实现之间建立了早期链接，在所有后续的迭代中我们一直在维护该链接

### 建立了一种基于模型的语言
* 双方都能够直接使用模型中的术语，并将它们组织为符合模型结构的语句，而且无需翻译即可理解互相要表达的意思

### 开发一个蕴含丰富知识的模型
* 对象具有行为和强制性规则
* 模型并不仅仅是一种数据模式，它还是解决复杂问题不可或缺的部分
* 模型包含各种类型的知识

### 提炼模型
* 重要的概念不断被添加到模型中，不再使用的或不重要的概念则从模型中被移除

### 头脑风暴和实验
* 基于模型的语言贯穿整个实现过程中的反馈闭环也对模型起到了“训练”作用
* 这种`知识消化`将团队的知识转化为有价值的模型

## 1.2 知识消化
* 高效的领域建模人员是知识的消化者
* 知识消化它一般是在开发人员的领导下，由开发人员与领域专家组成的团队来共同协作
* 共同收集信息，并通过消化而将它组织为有用的形式
* 信息的形式也多种多样：项目编写的文档，业务中使用的文件，来自大量的讨论
* 传统的`瀑布方法`
  * 顺序
    * 业务专家与分析员进行讨论
    * 分析员消化理解这些知识后，对其进行抽象并将结果传递给程序员
    * 由程序员编写软件代码
  * 弊端
    * 于这种方法完全没有反馈
    * 分析员全权负责创建模型，但他们创建的模型只是基于业务专家的意见，既没有向程序员学习的机会，也得不到早期软件版本的经验
    * 知识只是朝一个方向流动，而且不会累积
* `迭代过程`
  * 没有对知识进行抽象而无法建立起知识体系
  * 过程：
    * 开发人员听专家们描述某项所需的特性，然后开始构建它
    * 将结果展示给专家，并询问接下来做什么
    * 如果程序员愿意进行重构，则能够保持软件足够整洁，以便继续扩展它
    * 但如果程序员对领域不感兴趣，则他们只会了解程序应该执行的功能，而不去了解它背后的原理
  * 弊端
    * 项目`永远不会`从原有特性中自然地扩展出强大的新特性
* 一个好的程序员
  * 会自然而然地`抽象并开发`出一个可以完成更多工作的`模型`
  * 与`领域专家`密切协作
* 团队成员一起消化理解模型
  * 领域模型的不断精化迫使开发人员学习重要的`业务原理`，而不是机械地进行功能开发
  * 领域专家被迫提炼自己已知道的重要知识的过程往往也是完善其自身理解的过程，会渐渐理解软件项目所必需的`概念严谨性`
  * 促使团队成员成为更合格的知识消化者
  * 团队成员对知识`去粗取精`
  * 将模型重塑为更有用的形式
  * 分析员和程序员的知识输入模型：因此模型的`组织更严密`，`抽象更整洁`，从而为`实现`提供了更大支持
  * 领域专家们的知识输入模型：模型反映了业务的深层次知识，而且真正的业务原则得以`抽象`
* 模型的改进
  * 不断改进的同时也成为`组织项目信息流`的工具
  * 模型聚焦于`需求分析`
  * 与`编程`和`设计`紧密交互
  * 通过良性循环加深团队成员对领域的理解，使他们更透彻地`理解`模型，并对其进一步`精化`
  * 模型永远都不会是完美的，因为它是一个`不断演化完善的过程`
  * 模型对理解领域必须是`切实可用`的
  * 它们必须非常`精确`，以便使应用程序易于实现和理解

## 1.3 持续学习
## 1.4 知识丰富的设计
## 1.5 深层模型
