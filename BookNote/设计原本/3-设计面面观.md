# 设计面面观

## 第8章 设计中的理性主义与经验主义

```text
人人都会犯错，很多时候，大多数人都是在热情与兴趣的引诱下走向错误之渊

	 John Locke (1690),《An Essay Concerning Human Understanding))
```

```text
理解力有两种形式：直觉与推演，无论哪一种都需要以知识作为后盾。
        笛卡尔(1628), ((Rules for the Direction of the Mind》
```

### 理性主义与经验主义
* `经验主义者`认为仅仅依靠深思熟虑就`能`正确地设计好复杂的对象
* `理性主义者`认为仅仅依靠深思熟虑`不能`正确地设计好复杂的对象

### 软件设计

#### `理性主义者`
* 计算机程序是抽象的数学意义上的对象
* 通过证明来保证其正确性
* 即：人们所要做的就是深思熟虑。 人们可以也应该设计出正确的软件，然后证明设计是正确的，这就足够了

#### `经验主义者`
* 现在的程序则是纯粹的数学意义上的对象，原则上可以通过正确的思考做出完美的设计
* 困难并不在于设计方法而在于设计者本身
* 对于错误的这种坚 定信念产生出了这样一种设计方法学，它包括r设计、早期原型、早期用户测试、迭代式增量实现、使用大最测试用例进行测试以及在改变后进行回归测试

### 作者：经验主义者
* 问题的关键在于我们应该使用正确性证明技术
* 正式的正确性证明通常都是不可行的，完全放弃系统验证（更加极端的情况）相当危险

### 其他设计领域中的理性主义、经验主义与正确性

* 除了`软件工程`外，没有哪个设计领域的设计师尝试过通过严格的形式化方法来证正确性，但他们却通过无数的分析与模拟技术 广泛应用了设计骋证
* 因此严格的证明是可行的。其他大多数设计领域最终的结果都是`物理的实现`，人们无法证明与原料及其缺陷和空间及其适用性相关的原理
* `测试`与`迭代`是必不可少的。但细致入微的思考还是大有裨益的



## 第9章 用户模型——错误胜过含糊

```text
真理来源于错误而非混乱。
    —弗朗西斯-培根爵士(1620),《新工具》
```

### 明确的用户与用例模型
* 设计者一开始就将`对用户的了解`、`使用目的`以及`使用模式`等信息精确地记录在案
* 将对用户不了解以及假设的地方明确地记录下来
* [存在多个不同的应用或是不同类型的用户时]对每一个进行说明，然后明确 地规定他们的权重以便定义用例模型

---

* 明确的应用与用户模型的需求源自于现代化设计的特质：团队设计，复杂而非简单工具的设计


### 团队设计
* 每个人在使用类似系统时都会有不同的体验
* 团队设计中，不同的用例模型必然会产生不一致的设计
* 复杂设计

### 假如事实不可用该如何是好

#### 猜测
* `缜密的猜测胜于无言的假设`
* 对值与频率的猜测会强迫设计者仔细思考期望的用户集
* 显式地枚举值与频率有助于识别出决策所依赖的用户集属性

#### 错误胜过含糊
* 明确的假设即便是错误的也要好于含糊的。错误的假设起码会受到质疑，而含糊的则不会

## 第10章  预算资源

* 无论何种设计都至少存在一种稀缺资源需要限量或是预算
* 占据主导地位的资源叫做有限资源
* 预算资源可以在设计中期发生变化
* 预算资源对于设计团队来说是一种有益的指导
    * 明确确认：项目时间表
    * 公开跟踪
    * 严格控制
        * 只能有一个人来控制预算与重新预算

## 第11章  约束是我们的朋友
```text
格律是一种解放。
```
```text
通用产品要比特定用途的产品更难于设计。
```

#### 约束
* 约束会缩小设计者的探索空间
* 还会向设计者发起挑战，这常常有助于激发新的创造
* 人们必须、细心地区分
    * 真正的约束
    * 已经过去的、曾经真正的约束
    * 误认为真正的约束
    * 有意制造的约束
* 在开始设计时，你需要确定到底需要哪些东西而非如何得到它们
* 如果实现方法成为约束，那更好的解决方案就是终止这一切

#### 设计悖论：通用的产品要比特定用途的产品更难以设计
* 任何设计过程 都是以设计者对目标与约束的详细阐述和具体化开始的。 
* 首先要做的事情是缩小设计范围。指 定目标的约束越多，完成任务的可能性也就越大
* 设计优秀的通用架构。设计者还需要明确用例模型才能为通用架构进行恰当的设计
* 设计者必须理解全部应用，确定每一种应用的特殊需求并掌 握其平衡性
* 随着设计不断进行，必须将得到的结果与每类用户假设的特征进行比较。当设计完成并开发好原型后，必须让每类用户对原型进行测试

* 如果任务最初看起来没有约束，首先就需要仔细思考想要的用户与用例模型到底是什么，这样就会发现一些约束了，这对于设计者与用户来说都是好事

## 第12章  技术设计中的美学与风格
```text
好的建筑架构要满足“坚固、效用与情趣”的要求
        	--Marcus Vitruvius （公元前22年）
```
```text
风格是思想的外衣，良好的思想就像是穿着考究的帥士一样史具优势。
        —-Chesterfield勤齢（1774）,私函第240封
```
### 技术设计中的美学
* 我们在看到或使用某些设计时会感到很愉快，而其他具有相同功能与稳固性的设计则不会 给我们带来这种感觉，我们对这一点是很在意的
* 情趣可能是可见的、可听的、可闻的或是可 触的。它甚至有可能是纯粹的智力，就像是漂亮的证明或是良好的思想

### 何谓逻辑美
* 简约
    * 程序语言存在的目的是为了简化程序员编写与阅读代码的工作量，绝不能成为谜题一样的东西
* 结构清晰
    * 结构。技术设计中的“优雅”要求设计的基本结构性槪念要易于为人所理解，否则逻辑就 应该是直接且易于解释的。
    * 隐喻。“优雅”与可理解性都是通过使用熟悉且简单的隐喻实现的，尤其在设计对象的用 户界面上更是如此
* 一致性
    * 什么才是好的计算机架构 ：易于直接使用的架构通常叫做`整洁的架构`
    * 导出原则。3个主要的设计原则
        * 正交性：不要将独立的东西链接起来
        * 适宜性：不要引入无形的东西
        * 普遍性：不要限制固有的东西
    * 优点
        * 它会证实并鼓励我们的期望
        * 会解决`易用性`与`易学性`之间的冲突
            * 易学性需要简单的架构，正如定点运算一样
            * 易用性需要复杂的架构，正如浮点运算-样
  
### 技术设计中的风格

* 概念上的完整性是设计最重要的属性
* 设计最重要的完整性就在于 整体结构，这是设计的骨架
* 细节中也需要遵循一致的风格
* 一致的风格就是组件
* `产品的槪念完整性`有助于设计的可理解性。反过来，这又会简化学习、简化使用，在误用之后还能有助于回忆， 简化维护、简化扩展

### 何谓风格

* 一种细节特性
* 假设：将脑力劳动最小化。
    * 所有设计、创造都会涉及大最的微观决策。
    * 人类的习惯倾向于减少脑力劳动
    * 一直以来，微观决策表示着我们的工作并具备自己的特质、特殊性，这会使我 们具备可分辨的能力
* 微观决策的一致性。
    * 人们希望微观决策不仅在时间上是一致的，类似的决定也应该是一致的。
    * 在相关的微观决策中会有同样的因素，同样的思维自然而然地会以一致的方式衡量它们
* 清晰的风格。
    * 能以简约的方式描述它。它使得识别变得更加简单。

### 风格的属性
* 制定规范的代价是高昂的
* 规范是层次结构的
* 风格一直都在进化

### 要想获得一致的风格 -- 记录下来
* 设计风格是通过一套微观决议制定的
* 有抱负的设计者必须要为风格的一致性而奋斗
* 设计团队必须将设计恰当地记录下来，无论是工程图纸、构建蓝图还是用户手册 都是如此。他们还必须说出为何要获取设计者的意图，这样后续的维护者才不会遗漏掉重要的内容。这才是最终的产品。
* 团队还必须在维护阶段保持概念上的完整性，将管理与构成可视化 设计的各种微观决策记录下来

### 如何获得良好的风格
* 方法要直接，工作要努力
    * 有目的地去学习其他设计者的风格。练习另一种风格。这会强迫你对细节进行績密的思 考并明确想法。它还会得到重要的成果思考
    * 做出有意识的判断
    * 练习，练习，还是练习
    * 修正。看看不一致的风格
    * 仔细选择设计者。为你的产品选择拥有清晰风格与髙品位的设计者
## 第13章  设计中的范本

```text
……当你寻找某些东西时，只有事先了解了它们才有可能找到。如果不了解，你都不 知道去哪里找，或者是不知道是否已经找到了想要的东西。这再一次证明了当寻找某些东 西时，架构师的脑海中还是想着过去的方案与风格概念……
            —Bill Hillier^Alan Penn (1995), “存在一种领域无关的设计理论吗？-
```

### 很少会有全新的设计
* 共通的东西占多数
* 通常情况下，即便是创新的设计也是来自于之前为完成类似目的 所做的成果，并且构建在类似的技术之上

### 范例的角色
* 范本为新设计提供了安全的模型以及设计任务的隐式检査列表、潜在错误的警告，还可以 作为全新设计的出发点
* 好的设计者应该投入大量精力来学习判例
* 每个`设计者`都需要做,旨在做出优秀设计的技术设计原则需要具备可供访问的范本以及对它们的真知灼见

### 学习范本的设计原理
* 必须学习关于产品的技术文档与书籍才能搞清楚其（所在领域中的范本）基本原理

### 如何训练才能改进基于范本的设计
* `范例集合`：将这些系 统化的集合装配起来并发布出去
* `超越集合`
    * 1.集合搜集完后下一步就需要仔细、公平地考察特定的范本
    * 2.还需要进行分析 ：对范本进行比较，根据每个范本的目标进行评估
    * 3.进行比较分析：从每个示例中得出最佳实践规则以指导新的问题

### 范本——懒惰、创意与自满
* 设计者应该很清楚范本，了解它们的优势与缺陷。创意不应该成为无知的借口
* 工程与艺术不同，在工程当中，没有缘由的革新是愚蠢的想法，是自私的行为——因为这不可避免地会导致意外的后果。
* 掌握了其前辈风格的设计者具备了创意的基础，他们更容易实现创意
---
``懒惰``

* 在任何设计领域中都不能懒惰，都需要高度的热情与勤勉才能掌握大量的范本

``创意与自满``

* 把创意当做目标或意外收获
* 与创意之后的奋斗紧密相连的就是自满了，希望自己能够出名。长久以来，这都是人类失败的根源，它会影响到所有的设计并毁掉一切。
* 把欲望当做动力会让很多作品走向堕落

## 第14章  专业设计者缘何犯错

```text
但当我犯错时实际上却是一件好事！
	        --Fiorello La Guardia
	        
困扰专业设计者的错误不在于错误地设计了东西，而是设计了错误的东西。
```

### 错误
* Henry Petroski建议每次材料或技术革新后，设计者都应该完成如下事情
    * 谨慎进入
    * 掌握新的方法
    * 开始大胆的扩展，经常忘记潜在的假设
    * 大胆、自信过了头，或许由于狂妄和竞争压力感到很紧迫
* 对于专业设计者来说，成功是一件危险的事情
* 失败会促使人们去分析、仔细审査以及重 新思考。成功会导致设计技术与设计者过度自信。这两种信任可能会发生错位

### 曾经最糟糕的计算机语言

* IBM的Operating System/360 Job Control Language (JCL),
* 小结
    * 失败的例子要比成功的例子更值得我们细心研究
    * 成功后要审视自己。对于设计技术、设计本身以及我们自身来说，成功会激励我们自信。但这一切可能会导致过度自信
    * 从上层角度思考你的设计目标以及对目标所处的周边环境的假设。是否处于范式转移 中呢？你的假设在10年后还有效吗？你是在设计正确的东西吗？
## 第15章  设计的分离

### 设计与使用和实现的分离
* 20世纪在设计原则方面最大的进展之一就是设计者与实现者和用户的进一步分离
* 从自己的需要出发，构建工具给他们自己使用，并与其他人分离

### 为什么分离
* 20世纪在所有实现技术上的惊人进步要求专业化和更长的学习时间
* 现在设计的东西如此复杂，以致光是它们的 设计都要求专业化、更长的学习时间，以及所有设计者的努力

### 分离的结果
* 过度指定的实现使成 本超出了本来应有的成本，增加的功能或性能却不多
* 对于用户与设计者的联系、设计者与实现者的联系来说，他们之间的沟通带宽大大减小了

### 补救措施
* 1.用户场景体验
* 2.通过增量式设计和增量式交付与用户密切交互
    * Harlan Mills的增量式开发和迭代式交付体系，是从项目一开始就与用户保持密切接触的最佳方式
* 3.并发工程
    * 设计者需要投入更多精力，深入到实际的体验和实现过程中去。
    * 即使是单独的、不具代表性的实现经验，也可以很好地告诉设计者，实现的某个版本太过于理想化或不完整
    * 真正的实现者积极参与设计过程，他们的丰富经验为设计者有限的实现 样例提供了平衝。(在软件领域，同样的实践有时候就被称为敏捷方法。)
    * 能够抓住错误或 预见到实现的“陷阱二通过丰富的视图来増强标准平面图和局部图，甚至通过虚拟现实的环境来察看，可能使并发设计过程更顺畅
* 4.设计者的教育
    * 设计课程必须包括理解用户需求和期望的技术与实践
    * 分析技术和正式的综合方法是必要的工具，但高级的方法在需要时就会不言自明
    * 今天的设计课程必须考虑到设计的分离，并付出 巨大的努力让年轻的设计者接触到实现和使用的真实世界。

## 第16章  展现设计的演变途径和理由
```text
在修复你不懂的东西时，要小心。
```
### 简介
* 设计师要想从每次设计经历中学到最多的东西，他们就需要记录下设计的演进过程：`不仅说明设计是什么，而且说明设计为什么会变成这样`。
* 同时，这样的设计理由文档对系统维护者的帮助也非常大，它防止了许多无知之错。
* 记录下设计和演变途径和理由，这比初看起来要难得多

### 知识网线性化
#### 什么是设计树
* 每个设计问题（也就是要做出的决定）都是一个节点。
* 对于毎个可选的设计选项，每个设计-问题节点都有一个子节点。对每个独立的设计问题，设计者选择其中一个可选项。
* 大多数的选择带来更多的设计问题（例如，决定使用发光拨号盘之后，必须选择它的发光 机制）。这些设计-问题节点是以前的解决方案节点的子节点。因此这样的设计树包括独立或互斥的设计选择，完成的产品不是以单个节点的选择来表示的，而是以许多设计选择节点构成 的集合来表示的，选择的叶节点代表了每个独立设计问题的解决方案
* 为了展示设计这棵树的理由，每个选择都应该与一些节点关联起来，说明它的优点和缺点。 每个设计-问题节点也应该有一个关联的节点，说明所做的选择和理由
* 作者 ：每个设计问题用一个问题图标来表示。每个设计可选项用一个想法图标来表示。每个想法图标有优点和缺点两个子图标。选中的可选项变成一个同意图标，再带上一段理由注解
* 所有的设计问题，即使是独立的，也都应该根据屋子的空间按层次组织

### 深入设计过程
#### 设计不只是满足需求，也是发现需求
* 设计工作不仅是满足需求，它还引出需求
* 好的设计过程鼓励这种现象，而不是压制它

#### 设计不是简单地选择可选方案,也需要意识到存在潜在的可选方案
* 设计的一部分主要工作是意识到设计选项的存在

#### 设计变化时树也变化——如何展现演进过程
* 决策树的结构随着时间推移而发生变化。记录下这样的变化需要新的动态工具，而这样的 工具还不存在。它不仅必须追踪随着时间推移，树向叶节点方向的发展，也必须追踪节点和它们的子树从一个分枝上砍下，嫁接到另一个分枝上

### 决策树与设计树

* 最终完成的设计（即产品）不是表示为决策树上的一个节点，而是一组叶结点
* 所有可能设计构成的空间完全是一棵不同的树，其中每个节点确定了一些产品构成的子树,。每个叶节点 是一个不同的完整设计。
* 从组合等价的角度来看，设计树比对应的决策树更大。对于实际设计来说，设计树太麻烦了。
* 设计树这一概念是有教益的，有助于理清思路

### 模块化与紧密集成的设计

* 在一个决定的可选项之间进行选择时，很少与其他选择无关
* 这导致了一棵不雅观的决策树，因为某些可选解决方案必须与一些属性绑在一起
* 人们也可能在设计品质和设计过程的速度和容易性上进行折衷
* 模块化设计更容易表示为设计树。实际上，这可能就是我们采用模块化设计的意图
* 完全的模块化也有缺点：优化的设计有一些组件可以完成多个目标

